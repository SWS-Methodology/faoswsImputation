names(fits) = paste("Model", 1:length(fits), sep="_")
counts = data[,
sum(!is.na(get(imputationParameters$imputationValueColumn))),
by = c(imputationParameters$byKey)]
if(min(counts[, V1]) == 0 & !imputationParameters$estimateNoData)
stop("Some countries have no data.  Have you ran removeNoInfo?")
### If doing loocv, compute a new fits object
if(imputationParameters$errorType == "loocv")
fits = computeLoocvFits(data = data, cvGroup = cvGroup,
imputationParameters = imputationParameters)
fits
lapply(fits, function(x) x[data$geographicAreaM49 == 46])
if(!exists("ensuredImputationData") || !ensuredImputationData)
ensureImputationInputs(data = data,
imputationParameters = imputationParameters)
stopifnot(length(cvGroup) == nrow(data))
ensemModels = imputationParameters$ensembleModels
1:length(ensemModels)
i = 1
model = ensemModels[[i]]
fit = rep(NA, nrow(data))
model
fit = rep(NA, nrow(data))
fit
fit[data$geographicAreaM49 == 46]
which(data$geographicAreaM49 == 46)
unique(cvGroup[!is.na(cvGroup)])
i = 1
dataTemporary = copy(data)
dataTemporary[cvGroup == j,
c(imputationParameters$imputationValueColumn) := NA]
filter = data$geographicAreaM49 == 46
dataTemporary[filter,  ]
cvGroup[filter]
j
dataTemporary = copy(data)
dataTemporary[cvGroup == j,
c(imputationParameters$imputationValueColumn) := NA]
model@level == "commodity"
fitTemporary = model@model(data = dataTemporary,
imputationParameters =
imputationParameters)
fitTemporary
fitTemporary[filter]
model@model
data = dataTemporary
df = 1
weights
### Data Quality Checks
if(!exists("ensuredImputationData") || !ensuredImputationData)
ensureImputationInputs(data = data,
imputationParameters = imputationParameters)
uniqueByKey = data[!is.na(get(imputationParameters$imputationValueColumn)),
1, by = c(imputationParameters$byKey)]
if(nrow(uniqueByKey) <= 1) # Mixed model invalid if only one level:
return(rep(NA_real_, nrow(data)))
if("byKey" %in% colnames(data))
stop("defaultMixedModel assumes 'byKey' is not a column name of data")
## Make the key into one column by pasting all key columns together with
## a very unique symbol (:-: shouldn't show up in other keys on accident).
byKey = apply(data[, imputationParameters$byKey, with = FALSE],
1, function(x) paste(x, collapse = " :-: "))
data[, byKey := byKey]
model = try(
lme4::lmer(formula = modelFormula, data = data,
weights = weights,
REML = FALSE)
)
model
predict(model)
predict(model, newdata = data, allow.new.levels = TRUE)
predict(model, newdata = data, allow.new.levels = TRUE)[filter]
predict(model, newdata = data, allow.new.levels = TRUE)[data$region == 2]
dataTemporary$region
filter
dataTemporary[152, ]
dataTemporary[153, ]
modelFormula
modelFormula = formals(defaultMixedModel)$modelFormula
modelFormula
model = try(
lme4::lmer(formula = modelFormula, data = data,
weights = weights,
REML = FALSE)
)
model
modelFit = predict(model, newdata = data, allow.new.levels = TRUE)
predict(model, newdata = data, allow.new.levels = TRUE)[filter]
modelFormula
data
model = try(
lme4::lmer(formula = modelFormula, data = data,
weights = weights,
REML = FALSE)
)
names(model)
model
-205.34+1995*.1079
modelFormula
modelFormula = Value_measuredElement_5416 ~ timePointYears + (timePointYears |
geographicAreaM49/as.factor(region))
model = try(
lme4::lmer(formula = modelFormula, data = data,
weights = weights,
REML = FALSE)
)
modelFormula = Value_measuredElement_5416 ~ timePointYears + (timePointYears |
geographicAreaM49/region)
data[, region]
data[, region := as.factor(region)]
model = try(
lme4::lmer(formula = modelFormula, data = data,
weights = weights,
REML = FALSE)
)
modelFit = predict(model, newdata = data, allow.new.levels = TRUE)
modelFit[filter]
summary(modelFit)
summary(model)
formals(defaultMixedModel)$modelFormula = Value_measuredElement_5416 ~
timePointYears*region + (timePointYears|geographicAreaM49/region)
hierarchical = ensembleModel(model = defaultMixedModel, level = "commodity",
extrapolationRange = Inf)
globalMean = ensembleModel(model = defaultGlobalMean, level = "commodity",
extrapolationRange = Inf)
globalMedian = ensembleModel(model = defaultGlobalMedian, level = "commodity",
extrapolationRange = Inf)
newParameters$ensembleModels = list(hierarchical = hierarchical,
globalMean = globalMean,
globalMedian = globalMedian)
imputeVariable(data = mixedModelData, imputationParameters = newParameters)
data
data
modelFormula
modelFormula = Value_measuredElement_5416 ~ timePointYears * region + (timePointYears |
geographicAreaM49/region)
model = try(
lme4::lmer(formula = modelFormula, data = data,
weights = weights,
REML = FALSE)
)
model
-590.6+.3*1995
874.22-1995*.4422
874.22-1995*(.4422-.3022)
315.5245-1995*.1587
-590.6+.3*1995 + (874.2299-.4422*1995)
-590.6+.3*1995 + (315.5245-.1587*1995)
predict(model, newdata = data.frame(timePointYears = 1995:2010, region = 2, geographicAreaM49 = 0))
predict(model, newdata = data.frame(timePointYears = 1995:2010, region = factor(2, levels = c(1, 2, 3), geographicAreaM49 = 0))
)
predict(model, newdata = data.frame(timePointYears = 1995:2010, region = factor(2, levels = c(1, 2, 3)), geographicAreaM49 = 0))
predict(model, newdata = data.frame(timePointYears = 1995:2010, region = factor(2, levels = c(1, 2, 3)), geographicAreaM49 = 0)
predict(model, newdata = data.frame(timePointYears = 1995:2010, region = factor(2, levels = c(1, 2, 3)),
geographicAreaM49 = 0), allow.new.levels = TRUE)
predict(model, newdata = data.frame(timePointYears = 1995:2010, region = factor(2, levels = c(1, 2, 3)),
geographicAreaM49 = 1), allow.new.levels = TRUE)
predict(model, newdata = data.frame(timePointYears = 1995:2010, region = factor(2, levels = c(1, 2, 3)),
geographicAreaM49 = 46), allow.new.levels = TRUE)
data
data[filter, ]
predict(model, newdata = data[filter, ])
predict(model, newdata = data[filter, ], allow.new.levels = TRUE)
dim(data)
data
modelFit = predict(model, newdata = data, allow.new.levels = TRUE)
modelFit[filter]
modelFit = predict(model, newdata = data, allow.new.levels = TRUE)
modelFit
modelFit[filter]
fitTemporary = modelFit
filter = !is.na(cvGroup) & cvGroup == j
fit[filter] = fitTemporary[filter]
for(j in unique(cvGroup[!is.na(cvGroup)])){
#Copy x and remove the ith observation to fit the model
dataTemporary = copy(data)
dataTemporary[cvGroup == j,
c(imputationParameters$imputationValueColumn) := NA]
if(model@level == "commodity"){
fitTemporary = model@model(data = dataTemporary,
imputationParameters =
imputationParameters)
} else if(model@level == "countryCommodity"){
fitTemporary = extendSimpleModel(data = dataTemporary,
model = model@model,
imputationParameters =
imputationParameters)
}
filter = !is.na(cvGroup) & cvGroup == j
fit[filter] = fitTemporary[filter]
}
model = imputationParameters[[1]]
model
model = imputationParameters$ensembleModels[[1]]
model
for(j in unique(cvGroup[!is.na(cvGroup)])){
#Copy x and remove the ith observation to fit the model
dataTemporary = copy(data)
dataTemporary[cvGroup == j,
c(imputationParameters$imputationValueColumn) := NA]
if(model@level == "commodity"){
fitTemporary = model@model(data = dataTemporary,
imputationParameters =
imputationParameters)
} else if(model@level == "countryCommodity"){
fitTemporary = extendSimpleModel(data = dataTemporary,
model = model@model,
imputationParameters =
imputationParameters)
}
filter = !is.na(cvGroup) & cvGroup == j
fit[filter] = fitTemporary[filter]
}
imputationParameters$byKey
colnames(data)
data[, byKey := NULL]
colnames(data)
for(j in unique(cvGroup[!is.na(cvGroup)])){
#Copy x and remove the ith observation to fit the model
dataTemporary = copy(data)
dataTemporary[cvGroup == j,
c(imputationParameters$imputationValueColumn) := NA]
if(model@level == "commodity"){
fitTemporary = model@model(data = dataTemporary,
imputationParameters =
imputationParameters)
} else if(model@level == "countryCommodity"){
fitTemporary = extendSimpleModel(data = dataTemporary,
model = model@model,
imputationParameters =
imputationParameters)
}
filter = !is.na(cvGroup) & cvGroup == j
fit[filter] = fitTemporary[filter]
}
fit
fit[filter]
filter
cvGroup[filter]
source('~/Documents/SVN/RModules/faoswsImputation/R/defaultMixedModel.R')
source('~/Documents/SVN/RModules/faoswsImputation/R/computeLoocvFits.R')
source('~/Documents/SVN/RModules/faoswsImputation/R/computeEnsembleWeight.R')
source('~/Documents/SVN/RModules/faoswsImputation/R/ensembleImpute.R')
source('~/Documents/SVN/RModules/faoswsImputation/R/imputeVariable.R')
mixedModelData[geographicAreaM49 == "66", Value_measuredElement_5416 := NA]
mixedModelData[geographicAreaM49 == "66",
flagObservationStatus_measuredElement_5416 := "M"]
mixedModelData[,region := ifelse(geographicAreaM49 < 15, 1,
ifelse(geographicAreaM49 < 50, 2, 3))]
formals(defaultMixedModel)$modelFormula = Value_measuredElement_5416 ~
timePointYears*region + (timePointYears|geographicAreaM49/region)
hierarchical = ensembleModel(model = defaultMixedModel, level = "commodity",
extrapolationRange = Inf)
globalMean = ensembleModel(model = defaultGlobalMean, level = "commodity",
extrapolationRange = Inf)
globalMedian = ensembleModel(model = defaultGlobalMedian, level = "commodity",
extrapolationRange = Inf)
newParameters$ensembleModels = list(hierarchical = hierarchical,
globalMean = globalMean,
globalMedian = globalMedian)
imputeVariable(data = mixedModelData, imputationParameters = newParameters)
data = mixedModelData
imputationParameters = newParameters
missingIndex = is.na(
data[, get(imputationParameters$imputationValueColumn)])
setkeyv(x = data, cols = c(imputationParameters$byKey,
imputationParameters$yearValue))
## Build the ensemble
ensemble = data[[imputationParameters$imputationValueColumn]]
missIndex = is.na(ensemble)
cvGroup = makeCvGroup(data = data,
imputationParameters = imputationParameters)
cvGroup
data
data
cvGroup = makeCvGroup(data = data,
imputationParameters = imputationParameters)
modelFits = computeEnsembleFit(data = data,
imputationParameters = imputationParameters)
modelFits
modelWeights = computeEnsembleWeight(data = data,
cvGroup = cvGroup, fits = modelFits,
imputationParameters = imputationParameters)
modelWeights
modelWeights
data.frame(modelWeights)
fits = modelFits
if(!exists("ensuredImputationData") || !ensuredImputationData)
ensureImputationInputs(data = data,
imputationParameters = imputationParameters)
if(!all(lapply(fits, length) == nrow(data)))
stop("All elements of fits must have the same length as nrow(x)!")
stopifnot(all(names(fits) == names(imputationParameters$ensembleModels)))
if(is.null(names(fits)))
names(fits) = paste("Model", 1:length(fits), sep="_")
counts = data[,
sum(!is.na(get(imputationParameters$imputationValueColumn))),
by = c(imputationParameters$byKey)]
if(min(counts[, V1]) == 0 & !imputationParameters$estimateNoData)
stop("Some countries have no data.  Have you ran removeNoInfo?")
### If doing loocv, compute a new fits object
if(imputationParameters$errorType == "loocv")
fits = computeLoocvFits(data = data, cvGroup = cvGroup,
imputationParameters = imputationParameters)
fits
data[152, ]
data[153, ]
if(!exists("ensuredImputationData") || !ensuredImputationData)
ensureImputationInputs(data = data,
imputationParameters = imputationParameters)
stopifnot(length(cvGroup) == nrow(data))
ensemModels = imputationParameters$ensembleModels
ensemModels
fit
fits
i = 3
i =1
model = ensemModels[[i]]
fit = rep(NA, nrow(data))
model
fit = rep(NA, nrow(data))
cvGroup[data$geographicAreaM49 == 46]
j = 2
dataTemporary = copy(data)
dataTemporary[cvGroup == j,
c(imputationParameters$imputationValueColumn) := NA]
fitTemporary = model@model(data = dataTemporary,
imputationParameters =
imputationParameters)
fitTemporary[data$geographicAreaM49 == 46]
model@model
defaultMixedModel
defaultMixedModel(dataTemporary, imputationParameters = imputationParameters)
modelFormula
data
data
data = dataTemporary
defaultMixedModel(data, imputationParameters = imputationParameters)
if(!exists("ensuredImputationData") || !ensuredImputationData)
ensureImputationInputs(data = data,
imputationParameters = imputationParameters)
uniqueByKey = data[!is.na(get(imputationParameters$imputationValueColumn)),
1, by = c(imputationParameters$byKey)]
if(nrow(uniqueByKey) <= 1) # Mixed model invalid if only one level:
return(rep(NA_real_, nrow(data)))
if("byKey" %in% colnames(data))
stop("defaultMixedModel assumes 'byKey' is not a column name of data")
## Make the key into one column by pasting all key columns together with
## a very unique symbol (:-: shouldn't show up in other keys on accident).
byKey = apply(data[, imputationParameters$byKey, with = FALSE],
1, function(x) paste(x, collapse = " :-: "))
data[, byKey := byKey]
is.null(modelFormula)
model = try(
lme4::lmer(formula = modelFormula, data = data,
weights = weights,
REML = FALSE)
)
model
defaultModel
defaultMixedModel
modelFormula = Value_measuredElement_5416 ~
timePointYears * region + (timePointYears | geographicAreaM49/region)
model = try(
lme4::lmer(formula = modelFormula, data = data,
weights = weights,
REML = FALSE)
)
model
mixedModelData[,region := factor(ifelse(geographicAreaM49 < 15, 1,
ifelse(geographicAreaM49 < 50, 2, 3)))]
formals(defaultMixedModel)$modelFormula = Value_measuredElement_5416 ~
timePointYears*region + (timePointYears|geographicAreaM49/region)
hierarchical = ensembleModel(model = defaultMixedModel, level = "commodity",
extrapolationRange = Inf)
globalMean = ensembleModel(model = defaultGlobalMean, level = "commodity",
extrapolationRange = Inf)
globalMedian = ensembleModel(model = defaultGlobalMedian, level = "commodity",
extrapolationRange = Inf)
newParameters$ensembleModels = list(hierarchical = hierarchical,
globalMean = globalMean,
globalMedian = globalMedian)
imputeVariable(data = mixedModelData, imputationParameters = newParameters)
model = ensembleModel(model = defaultNaive, extrapolationRange = 0,
level = "countryCommodity")
imputationParameters$ensembleModels = list(model)
imputeVariable(data = exampleData, imputationParameters = imputationParameters)
getwd()
setwd("Documents/SVN/RModules/faoswsImputation/vignettes/")
knitr::knit2pdf("faoswsImputation.Rnw")
library(knitr)
opts_chunk$set(fig.path='figure/', fig.align='center', fig.show='hold',
warning=FALSE, message=FALSE, error=FALSE, tidy=FALSE,
results='markup', eval=TRUE, echo=TRUE, cache=FALSE, dpi=200)
options(replace.assign=TRUE,width=80)
assign("depthtrigger", 10, data.table:::.global)
## Load libraries
library(faoswsImputation)
library(faoswsUtil)
library(data.table)
library(faoswsProduction)
str(okrapd)
swsOldFlagTable = faoswsFlagTable
faoswsFlagTable$flagObservationStatus =
as.character(faoswsFlagTable$flagObservationStatus)
swsOldFlagTable
okraProcessed = copy(okrapd)
## Removing prior imputation for production
table(okraProcessed$flagObservationStatus_measuredElement_5510)
removeImputation(data = okraProcessed,
value = "Value_measuredElement_5510",
observationFlag =
"flagObservationStatus_measuredElement_5510",
methodFlag = "flagMethod_measuredElement_5510",
imputedFlag = "E",
missingObservationFlag = "M",
missingMethodFlag = "u")
table(okraProcessed$flagObservationStatus_measuredElement_5510)
## Removing prior imputation for area harvested
table(okraProcessed$flagObservationStatus_measuredElement_5312)
removeImputation(data = okraProcessed,
value = "Value_measuredElement_5312",
observationFlag =
"flagObservationStatus_measuredElement_5312",
methodFlag = "flagMethod_measuredElement_5312",
imputedFlag = "E",
missingObservationFlag = "M",
missingMethodFlag = "u")
table(okraProcessed$flagObservationStatus_measuredElement_5312)
## Removing prior imputation for yield
table(okraProcessed$flagObservationStatus_measuredElement_5416)
removeImputation(data = okraProcessed,
value = "Value_measuredElement_5416",
observationFlag =
"flagObservationStatus_measuredElement_5416",
methodFlag = "flagMethod_measuredElement_5416",
imputedFlag = "E",
missingObservationFlag = "M",
missingMethodFlag = "u")
table(okraProcessed$flagObservationStatus_measuredElement_5416)
okraProcessed[geographicAreaM49 == 12 & timePointYears >= 2005,
.(Value_measuredElement_5312,
flagObservationStatus_measuredElement_5312)]
remove0M(data = okraProcessed,
value = "Value_measuredElement_5312",
flag = "flagObservationStatus_measuredElement_5312",
naFlag = "M")
okraProcessed[geographicAreaM49 == 12 & timePointYears >= 2005,
.(Value_measuredElement_5312,
flagObservationStatus_measuredElement_5312)]
remove0M(data = okraProcessed,
value = "Value_measuredElement_5416",
flag = "flagObservationStatus_measuredElement_5416",
naFlag = "M")
remove0M(data = okraProcessed,
value = "Value_measuredElement_5510",
flag = "flagObservationStatus_measuredElement_5510",
naFlag = "M")
okraProcessed[geographicAreaM49 == 245,
.(Value_measuredElement_5416,
flagObservationStatus_measuredElement_5416)]
removeNoInfo(data = okraProcessed,
value = "Value_measuredElement_5416",
observationFlag = "flagObservationStatus_measuredElement_5416",
byKey = "geographicAreaM49")
okraProcessed[geographicAreaM49 == 245,
.(Value_measuredElement_5416,
flagObservationStatus_measuredElement_5416)]
processingParams = defaultProcessingParameters()
processingParams
okraProcessed = copy(okrapd)
processProductionDomain(data = okraProcessed,
processingParameters = processingParams)
okraProcessed = okraProcessed[geographicAreaM49 <= 60, ]
imputationParams = defaultImputationParameters(variable = "yield")
sapply(imputationParams, class)
names(imputationParams$ensembleModels)
imputationParams$ensembleModels =
imputationParams$ensembleModels[1:3]
names(imputationParams$ensembleModels)
newModel = ensembleModel(
model = function(data){
rep(10, length(data))
},
extrapolationRange = 5,
level = "countryCommodity")
is(newModel)
imputationParams$ensembleModels = c(imputationParams$ensembleModels,
newModel = newModel)
names(imputationParams$ensembleModels)
imputationParams$newImputationColumn = "test"
imputeVariable(data = okraProcessed, imputationParameters = imputationParams)
colnames(okraProcessed)
imputationParams$ensembleModels = imputationParams$ensembleModels[-4]
names(imputationParams$ensembleModels)
imputeVariable(data = okraProcessed, imputationParameters = imputationParams)
imputationParams$newImputationColumn = ""
imputeVariable(data = okraProcessed, imputationParameters = imputationParams)
okraProcessed[, c("Value_test", "flagObservationStatus_test",
"flagMethod_test") := NULL]
imputeVariable(data = okraProcessed, imputationParameters = imputationParams)
balanceProduction(data = okraProcessed,
imputationParameters = imputationParams,
processingParameters = processingParams)
imputationParams = defaultImputationParameters("production")
imputationParams$ensembleModels =
imputationParams$ensembleModels[4:9]
names(imputationParams$ensembleModels)
imputeVariable(data = okraProcessed,
imputationParameters = imputationParams)
balanceProduction
updateMissingFlags
